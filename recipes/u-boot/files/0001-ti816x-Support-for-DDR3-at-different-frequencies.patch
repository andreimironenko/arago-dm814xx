From 1c35470c5355a2e1c6e78a5a6759ebdca0af0d9f Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Wed, 29 Sep 2010 20:38:52 +0530
Subject: [PATCH 1/3] ti816x: Support for DDR3 at different frequencies

- This patch adds support for DDR3 at different frequencies on PG1.1 samples
 - Supported frequencies for DDR3: 400, 531, 675 and 796 MHz
 - Currently software leveling approach is used for DDR3 init
 - The ROM code bug which causes SYSCLK10 to run at half the expected frequency
   is now fixed by changing the PRCM divider instead of DDRPLL_MDIV2
 - Code for changing the core voltage to 1V via GPIOs is also added in lowlevel init

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/include/asm/arch-ti81xx/clocks_ti816x.h |   88 ++++++++--
 arch/arm/include/asm/arch-ti81xx/ddr_defs.h      |  132 ++++++++++++--
 board/ti/ti8168/evm.c                            |  212 +++++++++++++++-------
 include/configs/ti8168_evm.h                     |    5 +-
 4 files changed, 336 insertions(+), 101 deletions(-)

diff --git a/arch/arm/include/asm/arch-ti81xx/clocks_ti816x.h b/arch/arm/include/asm/arch-ti81xx/clocks_ti816x.h
index ae8e987..b8e9136 100644
--- a/arch/arm/include/asm/arch-ti81xx/clocks_ti816x.h
+++ b/arch/arm/include/asm/arch-ti81xx/clocks_ti816x.h
@@ -23,12 +23,13 @@
 
 /*
  * In TI816x the 27MHz crystal generates various root clks (main pll, audio pll, video pll and ddr pll)
- * From these root clks the SYSCLKs are generated by making use of dividers
+ * From these root clks the SYSCLKs are generated by making use of dividers and multipliers
  */
 
 #define FAPLL_K			8
 #define SYSCLK_2_DIV		1
 #define OSC_FREQ		27
+#define DDR_PLL_796	/* Values supported 400,531,675,796 */
 
 /* Main PLL */
 #define MAIN_N			64
@@ -48,19 +49,75 @@
 #define MAIN_INTFREQ5		0x9
 #define MAIN_FRACFREQ5		0x374BC6
 #define MAIN_MDIV5		0xC
-
 #define MAIN_MDIV6		0x48
 #define MAIN_MDIV7		0x4
 
 /* DDR PLL */
+/* For 400 MHz */
+#if defined(DDR_PLL_400)
 #define DDR_N			59
 #define DDR_P			0x1
-
 #define DDR_MDIV1		0x4
+#define DDR_INTFREQ2		0x8
+#define DDR_FRACFREQ2		0xD99999
+#define DDR_MDIV2		0x1E
+#define DDR_INTFREQ3		0x8
+#define DDR_FRACFREQ3		0x0
+#define DDR_MDIV3		0x4
+#define DDR_INTFREQ4		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ4		0x0
+#define DDR_MDIV4		0x4
+#define DDR_INTFREQ5		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ5		0x0
+#define DDR_MDIV5		0x4
+#endif
 
+/* For 531 MHz */
+#if defined(DDR_PLL_531)
+#define DDR_N			59
+#define DDR_P			0x1
+#define DDR_MDIV1		0x3
+#define DDR_INTFREQ2		0x8
+#define DDR_FRACFREQ2		0xD99999
+#define DDR_MDIV2		0x1E
+#define DDR_INTFREQ3		0x8
+#define DDR_FRACFREQ3		0x0
+#define DDR_MDIV3		0x4
+#define DDR_INTFREQ4		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ4		0x0
+#define DDR_MDIV4		0x4
+#define DDR_INTFREQ5		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ5		0x0
+#define DDR_MDIV5		0x4
+#endif
+
+/* For 675 MHz */
+#if defined(DDR_PLL_675)
+#define DDR_N			50
+#define DDR_P			0x1
+#define DDR_MDIV1		0x2
+#define DDR_INTFREQ2		0x9
+#define DDR_FRACFREQ2		0x000000
+#define DDR_MDIV2		0x19
+#define DDR_INTFREQ3		0x9
+#define DDR_FRACFREQ3		0x000000
+#define DDR_MDIV3		0x3
+#define DDR_INTFREQ4		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ4		0x0
+#define DDR_MDIV4		0x4
+#define DDR_INTFREQ5		0xE /* Expansion DDR clk */
+#define DDR_FRACFREQ5		0x0
+#define DDR_MDIV5		0x4
+#endif
+
+/* For 796 MHz */
+#if defined(DDR_PLL_796)
+#define DDR_N			59
+#define DDR_P			0x1
+#define DDR_MDIV1		0x2
 #define DDR_INTFREQ2		0x8
 #define DDR_FRACFREQ2		0xD99999
-#define DDR_MDIV2		0xF /* ROM code bug */
+#define DDR_MDIV2		0x1E
 #define DDR_INTFREQ3		0x8
 #define DDR_FRACFREQ3		0x0
 #define DDR_MDIV3		0x4
@@ -70,34 +127,35 @@
 #define DDR_INTFREQ5		0xE /* Expansion DDR clk */
 #define DDR_FRACFREQ5		0x0
 #define DDR_MDIV5		0x4
+#endif
 
 /* Video PLL */
-#define VIDEO_N		110
-#define VIDEO_P		0x2
+#define VIDEO_N			110
+#define VIDEO_P			0x2
 #define VIDEO_INTFREQ1		0xB
-#define VIDEO_FRACFREQ1	0x0
+#define VIDEO_FRACFREQ1		0x0
 #define VIDEO_MDIV1		0x5
 #define VIDEO_INTFREQ2		0xA
-#define VIDEO_FRACFREQ2	0x0
+#define VIDEO_FRACFREQ2		0x0
 #define VIDEO_MDIV2		0x2
 #define VIDEO_INTFREQ3		0xA
-#define VIDEO_FRACFREQ3	0x0
+#define VIDEO_FRACFREQ3		0x0
 #define VIDEO_MDIV3		0x2
 
 /* Audio PLL */
-#define AUDIO_N		64
-#define AUDIO_P		0x19
+#define AUDIO_N			64
+#define AUDIO_P			0x19
 #define AUDIO_INTFREQ2		0xE
-#define AUDIO_FRACFREQ2	0x0
+#define AUDIO_FRACFREQ2		0x0
 #define AUDIO_MDIV2		0x4
 #define AUDIO_INTFREQ3		0x9
-#define AUDIO_FRACFREQ3	0x0
+#define AUDIO_FRACFREQ3		0x0
 #define AUDIO_MDIV3		0x5
 #define AUDIO_INTFREQ4		0x9
-#define AUDIO_FRACFREQ4	0xCBC148
+#define AUDIO_FRACFREQ4		0xCBC148
 #define AUDIO_MDIV4		0x14
 #define AUDIO_INTFREQ5		0xD
-#define AUDIO_FRACFREQ5	0x800000
+#define AUDIO_FRACFREQ5		0x800000
 #define AUDIO_MDIV5		0x14
 
 #endif	/* endif _CLOCKS_TI816X_H_ */
diff --git a/arch/arm/include/asm/arch-ti81xx/ddr_defs.h b/arch/arm/include/asm/arch-ti81xx/ddr_defs.h
index 5fb4539..f15985f 100644
--- a/arch/arm/include/asm/arch-ti81xx/ddr_defs.h
+++ b/arch/arm/include/asm/arch-ti81xx/ddr_defs.h
@@ -24,6 +24,11 @@
 #include <asm/arch/hardware.h>
 
 #ifdef CONFIG_TI816X_EVM_DDR3
+
+#define CONFIG_TI816X_DDR3_796 /* Values supported 400,531,675,796 */
+#define CONFIG_TI816X_DDR3_SW_LEVELING	/* Enable software leveling as part of DDR3 init*/
+
+
 /*
  * DDR3 force values.  These are board dependent
  */
@@ -53,16 +58,17 @@
 #define CMD_SLAVE_FROM_INV_CLOCK(i) (((i)==0) ? 0x80 : 0x100)
 #define CMD_SLAVE_RATIO		CMD_SLAVE_FROM_INV_CLOCK(INVERT_CLOCK)
 
+#ifdef TI816X_DDR3_PG_1_0
 /*
  * EMIF PHY allows for controlling write DQS delay w.r.t. clock.  The
  * value may be forced or use values determined from the leveling
  * process.  Since we are doing the leveling - these are actually
  * don't care and are not used.  The force is in delay units
  */
-#define WR_DQS_FORCE_3		0x00000010
-#define WR_DQS_FORCE_2  	0x00000010
-#define WR_DQS_FORCE_1  	0x00000010
-#define WR_DQS_FORCE_0  	0x00000010
+#define WR_DQS_FORCE_3	0x00000010
+#define WR_DQS_FORCE_2	0x00000010
+#define WR_DQS_FORCE_1	0x00000010
+#define WR_DQS_FORCE_0	0x00000010
 
 /*
  * EMIF PHY allows for controlling how much the read DQS must be
@@ -90,6 +96,8 @@
 #define RD_GATE_FORCE_1	0x44
 #define RD_GATE_FORCE_0	0x44
 
+#endif
+
 /*
  * This represents the initial value for the leveling process.  The
  * value is a ratio - so 0x100 represents one cycle.  The real delay
@@ -100,11 +108,12 @@
  * values such that byte3 completes leveling after byte2 and byte1
  * after byte0.
  */
-#define WR_DQS_RATIO_0		0x40
+#define WR_DQS_RATIO_0		0x20
 #define WR_DQS_RATIO_1		0x20
-#define WR_DQS_RATIO_2		0x40
+#define WR_DQS_RATIO_2		0x20
 #define WR_DQS_RATIO_3		0x20
 
+#ifdef TI816X_DDR3_PG_1_0
 /*
  * read dqs ratio is only used in DDR2
  */
@@ -112,6 +121,7 @@
 #define RD_DQS_RATIO_1		0x40
 #define RD_DQS_RATIO_2		0x40
 #define RD_DQS_RATIO_3		0x40
+#endif
 
 /*
  * This represents the initial value for the leveling process.  The
@@ -123,11 +133,12 @@
  * values such that byte3 completes leveling after byte2 and byte1
  * after byte0.
  */
-#define RD_GATE_RATIO_0	0x38
+#define RD_GATE_RATIO_0	0x20
 #define RD_GATE_RATIO_1	0x20
-#define RD_GATE_RATIO_2	0x38
+#define RD_GATE_RATIO_2	0x20
 #define RD_GATE_RATIO_3	0x20
 
+#ifdef TI816X_DDR3_PG_1_0
 /*
  * currently there is an issue with the automatic training process for
  * DDR3 by setting the initial leveling ratios appropriately we are
@@ -138,7 +149,7 @@
  * leveling process complete by forcing good and bad values
  * This is enabled via HACK_EYE_TRAINING
  */
-#define HACK_EYE_TRAINING	1
+#define HACK_EYE_TRAINING	0
 
 /*
  * only the rd dqs delay needs to be forced.  Others are determined via the leveling process
@@ -147,6 +158,7 @@
 #define USE_RD_DQS_FORCE	HACK_EYE_TRAINING
 #define USE_RD_GATE_FORCE	0
 
+#endif
 /*
  * data rate in MHz.  The DDR clock will be 1/2 of this value
  */
@@ -159,19 +171,107 @@
  * EMIF Paramters.  Refer the EMIF register documentation and the
  * memory datasheet for details
  */
-#define EMIF_TIM1    0x0CCCE524  /* relaxed timing values - optimal 0AAAD4E3 */
-#define EMIF_TIM2    0x30308023  /* relaxed timing valeus - optimal 242F7FDA */
-#define EMIF_TIM3    0x009F82CF  /* relaxed timing valeus - optimal 009F82B8 */
-#define EMIF_SDREF   0x10000C30  /* optimal refresh interval - 10000C30 */
-#define EMIF_SDCFG   0x62A452B2  /* 16 bit ddr3, CL=6, CWL=5, 14 rows, 8 banks, 10 bit column, 1 CS */
-#define EMIF_PHYCFG  0x0000030B  /* local odt = 3, read latency = 11 (max = 12, min=6) */
+/* For 400 MHz */
+#if defined(CONFIG_TI816X_DDR3_400)
+#define EMIF_TIM1    0x0CCCE524
+#define EMIF_TIM2    0x30308023
+#define EMIF_TIM3    0x009F82CF
+#define EMIF_SDREF   0x10000C30
+#define EMIF_SDCFG   0x62A41032
+#define EMIF_PHYCFG  0x0000030B
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x12A
+#define RD_DQS		0x3B
+#define WR_DQS		0xA6
+#endif
+
+#endif	/* CONFIG_TI816X_DDR3_400 */
+
+/* For 531 MHz */
+#if defined(CONFIG_TI816X_DDR3_531)
+#define EMIF_TIM1    0x0EF136AC
+#define EMIF_TIM2    0x30408063
+#define EMIF_TIM3    0x009F83AF
+#define EMIF_SDREF   0x1000102E
+#define EMIF_SDCFG   0x62A51832
+#define EMIF_PHYCFG  0x0000030C
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x13D
+#define RD_DQS		0x39
+#define WR_DQS		0xB4
+#endif
+
+#endif /* CONFIG_TI816X_DDR_531 */
+
+/* For 675 MHz */
+#if defined(CONFIG_TI816X_DDR3_675)
+#define EMIF_TIM1    0x13358875
+#define EMIF_TIM2    0x5051806C
+#define EMIF_TIM3    0x009F84AF
+#define EMIF_SDREF   0x10001491
+#define EMIF_SDCFG   0x62A63032
+#define EMIF_PHYCFG  0x0000030F
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x196
+#define RD_DQS		0x39
+#define WR_DQS		0x91
+
+#endif
+
+#endif /* CONFIG_TI816X_DDR3_675 */
+
+/* For 796 MHz */
+#if defined(CONFIG_TI816X_DDR3_796)
+#define EMIF_TIM1   0x1779C9FE
+#define EMIF_TIM2   0x50608074
+#define EMIF_TIM3   0x009F857F
+#define EMIF_SDREF  0x10001841
+#define EMIF_SDCFG  0x62A73832
+#define EMIF_PHYCFG 0x00000310
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+/* These values are obtained from the CCS app */
+#define RD_DQS_GATE	0x1B3
+#define RD_DQS		0x35
+#define WR_DQS		0x93
+
+#endif
+
+#endif /* CONFIG_TI816X_DDR_796 */
+
+
+#if defined(CONFIG_TI816X_DDR3_SW_LEVELING)
+#define WR_DQS_RATIO_BYTE_LANE3	((WR_DQS << 10) | WR_DQS)
+#define WR_DQS_RATIO_BYTE_LANE2	((WR_DQS << 10) | WR_DQS)
+#define WR_DQS_RATIO_BYTE_LANE1	((WR_DQS << 10) | WR_DQS)
+#define WR_DQS_RATIO_BYTE_LANE0	((WR_DQS << 10) | WR_DQS)
+
+#define WR_DATA_RATIO_BYTE_LANE3	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE2	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE1	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+#define WR_DATA_RATIO_BYTE_LANE0	(((WR_DQS + 0x40) << 10) | (WR_DQS + 0x40))
+
+#define RD_DQS_RATIO			((RD_DQS << 10) | RD_DQS)
+
+#define DQS_GATE_BYTE_LANE0		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+#define DQS_GATE_BYTE_LANE1		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+#define DQS_GATE_BYTE_LANE2		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+#define DQS_GATE_BYTE_LANE3		((RD_DQS_GATE << 10) | RD_DQS_GATE)
+
+#endif	/* CONFIG_TI816X_DDR3_SW_LEVELING */
 
 #endif	/* CONFIG_TI816X_EVM_DDR3 */
 
 #ifdef CONFIG_TI816X_EVM_DDR2
 
 #define INVERT_CLK_OUT		0x0
-#define CMD_SLAVE_RATIO	0x80
+#define CMD_SLAVE_RATIO		0x80
 /*
  * DDR2 ratio values.  These are board dependent
  * obtained from sweep experiments
diff --git a/board/ti/ti8168/evm.c b/board/ti/ti8168/evm.c
index e99e1cf..fb6e6a3 100644
--- a/board/ti/ti8168/evm.c
+++ b/board/ti/ti8168/evm.c
@@ -66,6 +66,7 @@ DECLARE_GLOBAL_DATA_PTR;
 void walking_one_test(unsigned long start_addr, unsigned long end_addr);
 void data_walking_test(unsigned long addr, unsigned long mask);
 void address_walking_test(unsigned long addr, unsigned long mask);
+static void ddr3_sw_levelling(int emif);
 
 #ifdef CONFIG_TI816X_VOLT_SCALE
 #define NUM_VOLT_DATA 4
@@ -236,13 +237,16 @@ static void ddr_init_settings(int emif)
 	 * prevent this reset.  If the reset happens it would cause
 	 * the data to be corrupted.
 	 */
-	__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x028);
-	__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x05C);
-	__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x090);
-	__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x138);
-	__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x1DC);
-	__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x280);
-	__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x324);
+	if(0 == get_cpu_rev())
+	{
+		__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x028);
+		__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x05C);
+		__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x090);
+		__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x138);
+		__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x1DC);
+		__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x280);
+		__raw_writel(0xF, DDRPHY_CONFIG_BASE + 0x324);
+	}
 
 	/*
 	 * setup use_rank_delays to 1.  This is only necessary when
@@ -298,6 +302,7 @@ static void ddr_init_settings(int emif)
 	__raw_writel((RD_GATE_RATIO_0 << 10) | RD_GATE_RATIO_0, DDRPHY_CONFIG_BASE + 0x2E8); /*  data3 gatelvl init ratio */
 	__raw_writel(0x0, DDRPHY_CONFIG_BASE + 0x2EC);
 
+#ifdef CONFIG_TI816X_DDR3_PG_1_0
 	if(HACK_EYE_TRAINING){
 		__raw_writel((RD_DQS_FORCE_3 << 9) | RD_DQS_FORCE_3, DDRPHY_CONFIG_BASE + 0x0D4);
 		__raw_writel(0x00000001, DDRPHY_CONFIG_BASE + 0x0D0);
@@ -313,6 +318,7 @@ static void ddr_init_settings(int emif)
 		__raw_writel(0x00000001, DDRPHY_CONFIG_BASE + 0x2BC);
 	}
 	/* DDR3 */
+#endif
 
 	__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x00C);     /* cmd0 io config - output impedance of pad */
 	__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x010);     /* cmd0 io clk config - output impedance of pad */
@@ -329,11 +335,13 @@ static void ddr_init_settings(int emif)
 	__raw_writel(0x4, DDRPHY_CONFIG_BASE + 0x294);     /* data3 io config - output impedance of pa */
 	__raw_writel(0x4, DDRPHY_CONFIG_BASE + 0x298);     /* data3 io clk config - output impedance of pad */
 
-	__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x338);     /* fifo_we_out0  - output impedance of pad */
-	__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x340);     /* fifo_we_out1 - output impedance of pad */
-	__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x348);     /* fifo_we_in2 - output impedance of pad */
-	__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x350);     /* fifo_we_in3 - output impedance of pad */
-
+	if(0 == get_cpu_rev())
+	{
+		__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x338);     /* fifo_we_out0  - output impedance of pad */
+		__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x340);     /* fifo_we_out1 - output impedance of pad */
+		__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x348);     /* fifo_we_in2 - output impedance of pad */
+		__raw_writel(0x5, DDRPHY_CONFIG_BASE + 0x350);     /* fifo_we_in3 - output impedance of pad */
+	}
 }
 
 static void emif4p_init(u32 TIM1, u32 TIM2, u32 TIM3, u32 SDREF, u32 SDCFG, u32 RL)
@@ -347,12 +355,11 @@ static void emif4p_init(u32 TIM1, u32 TIM2, u32 TIM3, u32 SDREF, u32 SDCFG, u32
 		__raw_writel(TIM3, EMIF4_0_SDRAM_TIM_3);
 		__raw_writel(TIM3, EMIF4_0_SDRAM_TIM_3_SHADOW);
 		__raw_writel(SDCFG, EMIF4_0_SDRAM_CONFIG);
-		//__raw_writel(SDREF, EMIF4_0_SDRAM_REF_CTRL);
-		//__raw_writel(SDREF, EMIF4_0_SDRAM_REF_CTRL_SHADOW);
 		__raw_writel(RL, EMIF4_0_DDR_PHY_CTRL_1);
 		__raw_writel(RL, EMIF4_0_DDR_PHY_CTRL_1_SHADOW);
 		__raw_writel(0x0000613B, EMIF4_0_SDRAM_REF_CTRL);   /* initially a large refresh period */
 		__raw_writel(0x1000613B, EMIF4_0_SDRAM_REF_CTRL);   /* trigger initialization           */
+		__raw_writel((0x10000000|EMIF_SDREF), EMIF4_0_SDRAM_REF_CTRL);
 	}
 
 	if(USE_EMIF1){
@@ -364,14 +371,18 @@ static void emif4p_init(u32 TIM1, u32 TIM2, u32 TIM3, u32 SDREF, u32 SDCFG, u32
 		__raw_writel(TIM3, EMIF4_1_SDRAM_TIM_3);
 		__raw_writel(TIM3, EMIF4_1_SDRAM_TIM_3_SHADOW);
 		__raw_writel(SDCFG, EMIF4_1_SDRAM_CONFIG);
-		//__raw_writel(SDREF, EMIF4_1_SDRAM_REF_CTRL);
-		//__raw_writel(SDREF, EMIF4_1_SDRAM_REF_CTRL_SHADOW);
 		__raw_writel(RL, EMIF4_1_DDR_PHY_CTRL_1);
 		__raw_writel(RL, EMIF4_1_DDR_PHY_CTRL_1_SHADOW);
-		__raw_writel(0x0000613B, EMIF4_0_SDRAM_REF_CTRL);   /* initially a large refresh period */
-		__raw_writel(0x1000613B, EMIF4_0_SDRAM_REF_CTRL);   /* trigger initialization           */
+		__raw_writel(0x0000613B, EMIF4_1_SDRAM_REF_CTRL);   /* initially a large refresh period */
+		__raw_writel(0x1000613B, EMIF4_1_SDRAM_REF_CTRL);   /* trigger initialization           */
+		__raw_writel((0x10000000|EMIF_SDREF), EMIF4_1_SDRAM_REF_CTRL);
 	}
 
+	delay(1000);
+#ifdef CONFIG_TI816X_DDR3_SW_LEVELING
+	ddr3_sw_levelling(0);
+	ddr3_sw_levelling(1);
+#endif
 }
 
 static void config_ti816x_sdram_ddr(void)
@@ -379,7 +390,7 @@ static void config_ti816x_sdram_ddr(void)
 	__raw_writel(0x2, CM_DEFAULT_FW_CLKCTRL);				/*Enable the EMIF Firewall clocks */
 	__raw_writel(0x2, CM_DEFAULT_L3_FAST_CLKSTCTRL);			/*Enable the Power Domain Transition of L3 Fast Domain Peripheral*/
 	__raw_writel(0x2, CM_DEFAULT_EMIF_0_CLKCTRL);				/*Enable EMIF0 Clock*/
-	__raw_writel(0x2, CM_DEFAULT_EMIF_1_CLKCTRL); 				/*Enable EMIF1 Clock*/
+	__raw_writel(0x2, CM_DEFAULT_EMIF_1_CLKCTRL);				/*Enable EMIF1 Clock*/
 	while((__raw_readl(CM_DEFAULT_L3_FAST_CLKSTCTRL) & 0x300) != 0x300);	/*Poll for L3_FAST_GCLK  & DDR_GCLK  are active*/
 	while((__raw_readl(CM_DEFAULT_EMIF_0_CLKCTRL)) != 0x2);	/*Poll for Module is functional*/
 	while((__raw_readl(CM_DEFAULT_EMIF_1_CLKCTRL)) != 0x2);	/*Poll for Module is functional*/
@@ -392,22 +403,29 @@ static void config_ti816x_sdram_ddr(void)
 		ddr_init_settings(1);
 	}
 
-
-	__raw_writel(0x2, CM_DEFAULT_DMM_CLKCTRL); 			/*Enable EMIF1 Clock*/
+	__raw_writel(0x2, CM_DEFAULT_DMM_CLKCTRL);			/*Enable EMIF1 Clock*/
 	while((__raw_readl(CM_DEFAULT_DMM_CLKCTRL)) != 0x2);		/*Poll for Module is functional*/
 
-	/*Program the DMM to Access EMIF0*/
-	__raw_writel(0x80400100, DMM_LISA_MAP__0);
-	__raw_writel(0xC0400110, DMM_LISA_MAP__1);
+#if 0
+	/* Program the DMM to for non-interleaved configuration */
+	__raw_writel(0x0, DMM_LISA_MAP__0);
+	__raw_writel(0x0, DMM_LISA_MAP__1);
+	__raw_writel(0x80500100, DMM_LISA_MAP__2);
+	__raw_writel(0xA0500200, DMM_LISA_MAP__3);
+#endif
+
+	/* Program the DMM to for interleaved configuration */
+	__raw_writel(0x80640300, DMM_LISA_MAP__0);
+	__raw_writel(0xC0640320, DMM_LISA_MAP__1);
+	__raw_writel(0x80640300, DMM_LISA_MAP__2);
+	__raw_writel(0xC0640320, DMM_LISA_MAP__3);
 
-	/*Program the DMM to Access EMIF1*/
-	__raw_writel(0x90400200, DMM_LISA_MAP__2);
-	__raw_writel(0xB0400210, DMM_LISA_MAP__3);
 	/*Enable Tiled Access*/
 	__raw_writel(0x80000000, DMM_PAT_BASE_ADDR);
 
-	emif4p_init(EMIF_TIM1, EMIF_TIM2, EMIF_TIM3, EMIF_SDREF & 0xFFFFFFFF, EMIF_SDCFG, EMIF_PHYCFG);
+	emif4p_init(EMIF_TIM1, EMIF_TIM2, EMIF_TIM3, EMIF_SDREF & 0xFFFFFFF, EMIF_SDCFG, EMIF_PHYCFG);
 
+#ifdef CONFIG_TI816X_DDR3_PG_1_0
 	if(HACK_EYE_TRAINING) {
 		ddr_delay(10000);
 
@@ -465,21 +483,75 @@ static void config_ti816x_sdram_ddr(void)
 	}
 
 	walking_one_test(0x80000000, 0x9fffffff);
-}
 #endif
+}
 
+#ifdef CONFIG_TI816X_DDR3_SW_LEVELING
+static void ddr3_sw_levelling(int emif)
+{
+	__raw_writel(0x6, (DDRPHY_CONFIG_BASE + 0x358));
+
+	__raw_writel(DQS_GATE_BYTE_LANE0, (DDRPHY_CONFIG_BASE + 0x108));
+	__raw_writel(0x00000000, (DDRPHY_CONFIG_BASE + 0x10C));
+	__raw_writel(DQS_GATE_BYTE_LANE1, (DDRPHY_CONFIG_BASE + 0x1AC));
+	__raw_writel(0x00000000, (DDRPHY_CONFIG_BASE + 0x1B0));
+	__raw_writel(DQS_GATE_BYTE_LANE2, (DDRPHY_CONFIG_BASE + 0x250));
+	__raw_writel(0x00000000, (DDRPHY_CONFIG_BASE + 0x254));
+	__raw_writel(DQS_GATE_BYTE_LANE3, (DDRPHY_CONFIG_BASE + 0x2F4));
+	__raw_writel(0x00000000, (DDRPHY_CONFIG_BASE + 0x2F8));
+
+	__raw_writel(WR_DQS_RATIO_BYTE_LANE0, (DDRPHY_CONFIG_BASE + 0x0DC));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x0E0));
+	__raw_writel(WR_DQS_RATIO_BYTE_LANE1, (DDRPHY_CONFIG_BASE + 0x180));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x184));
+	__raw_writel(WR_DQS_RATIO_BYTE_LANE2, (DDRPHY_CONFIG_BASE + 0x224));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x228));
+	__raw_writel(WR_DQS_RATIO_BYTE_LANE3, (DDRPHY_CONFIG_BASE + 0x2C8));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x2CC));
+
+	__raw_writel(WR_DATA_RATIO_BYTE_LANE0, (DDRPHY_CONFIG_BASE + 0x120));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x124));
+	__raw_writel(WR_DATA_RATIO_BYTE_LANE1, (DDRPHY_CONFIG_BASE + 0x1C4));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x1C8));
+	__raw_writel(WR_DATA_RATIO_BYTE_LANE2, (DDRPHY_CONFIG_BASE + 0x268));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x26C));
+	__raw_writel(WR_DATA_RATIO_BYTE_LANE3, (DDRPHY_CONFIG_BASE + 0x30C));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x310));
+
+	__raw_writel(RD_DQS_RATIO, (DDRPHY_CONFIG_BASE + 0x0C8));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x0CC));
+	__raw_writel(RD_DQS_RATIO, (DDRPHY_CONFIG_BASE + 0x16C));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x170));
+	__raw_writel(RD_DQS_RATIO, (DDRPHY_CONFIG_BASE + 0x210));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x214));
+	__raw_writel(RD_DQS_RATIO, (DDRPHY_CONFIG_BASE + 0x2B4));
+	__raw_writel(0x0, (DDRPHY_CONFIG_BASE + 0x2B8));
+
+
+}
+#endif /* CONFIG_TI816X_DDR3_SW_LEVELING */
+
+#endif /* CONFIG_TI816X_EVM_DDR3 */
 
 #ifdef CONFIG_TI816X_EVM_DDR2
 static void ddr_init_settings(int emif)
 {
 	/* DLL Lockdiff */
-	__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x028));
-	__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x05C));
-	__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x090));
-	__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x138));
-	__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x1DC));
-	__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x280));
-	__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x324));
+	if(0 == get_cpu_rev())
+	{
+		__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x028));
+		__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x05C));
+		__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x090));
+		__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x138));
+		__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x1DC));
+		__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x280));
+		__raw_writel(0xF, (DDRPHY_CONFIG_BASE + 0x324));
+	}
+
+	if(1 == get_cpu_rev())
+	{
+		__raw_writel(0x6, (DDRPHY_CONFIG_BASE + 0x358));
+	}
 
 	/* setup rank delays */
 	__raw_writel(0x1, (DDRPHY_CONFIG_BASE + 0x134));
@@ -549,10 +621,13 @@ static void ddr_init_settings(int emif)
 	__raw_writel(0x4, (DDRPHY_CONFIG_BASE + 0x294));
 	__raw_writel(0x4, (DDRPHY_CONFIG_BASE + 0x298));
 
-	__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x338));
-	__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x340));
-	__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x348));
-	__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x350));
+	if(0 == get_cpu_rev())
+	{
+		__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x338));
+		__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x340));
+		__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x348));
+		__raw_writel(0x5, (DDRPHY_CONFIG_BASE + 0x350));
+	}
 
 }
 
@@ -566,8 +641,6 @@ static void emif4p_init(u32 TIM1, u32 TIM2, u32 TIM3, u32 SDREF, u32 SDCFG, u32
 	__raw_writel(TIM3, EMIF4_0_SDRAM_TIM_3);
 	__raw_writel(TIM3, EMIF4_0_SDRAM_TIM_3_SHADOW);
 	__raw_writel(SDCFG, EMIF4_0_SDRAM_CONFIG);
-	//__raw_writel(SDREF, EMIF4_0_SDRAM_REF_CTRL);
-	//__raw_writel(SDREF, EMIF4_0_SDRAM_REF_CTRL_SHADOW);
 	__raw_writel(RL, EMIF4_0_DDR_PHY_CTRL_1);
 	__raw_writel(RL, EMIF4_0_DDR_PHY_CTRL_1_SHADOW);
 
@@ -579,45 +652,31 @@ static void emif4p_init(u32 TIM1, u32 TIM2, u32 TIM3, u32 SDREF, u32 SDCFG, u32
 	__raw_writel(TIM3, EMIF4_1_SDRAM_TIM_3);
 	__raw_writel(TIM3, EMIF4_1_SDRAM_TIM_3_SHADOW);
 	__raw_writel(SDCFG, EMIF4_1_SDRAM_CONFIG);
-	//__raw_writel(SDREF, EMIF4_0_SDRAM_REF_CTRL);
-	//__raw_writel(SDREF, EMIF4_0_SDRAM_REF_CTRL_SHADOW);
 	__raw_writel(RL, EMIF4_1_DDR_PHY_CTRL_1);
 	__raw_writel(RL, EMIF4_1_DDR_PHY_CTRL_1_SHADOW);
 	}
 
-}
-
-static void ddrsetup(void)
-{
 	/* setup a small control period */
 	__raw_writel(0x0000613B, EMIF4_0_SDRAM_REF_CTRL);
 	__raw_writel(0x1000613B, EMIF4_0_SDRAM_REF_CTRL);
-	__raw_writel(0x10000C30, EMIF4_0_SDRAM_REF_CTRL);
-
-	__raw_writel(EMIF_PHYCFG, EMIF4_0_DDR_PHY_CTRL_1);
-	__raw_writel(EMIF_PHYCFG, EMIF4_0_DDR_PHY_CTRL_1_SHADOW);
+	__raw_writel((0x10000000|SDREF), EMIF4_0_SDRAM_REF_CTRL);
 
 	if (CONFIG_TI816X_TWO_EMIF){
 	/* setup a small control period */
 	__raw_writel(0x0000613B, EMIF4_1_SDRAM_REF_CTRL);
 	__raw_writel(0x1000613B, EMIF4_1_SDRAM_REF_CTRL);
-	__raw_writel(0x10000C30, EMIF4_1_SDRAM_REF_CTRL);
+	__raw_writel((0x10000000|SDREF), EMIF4_1_SDRAM_REF_CTRL);
 
-	__raw_writel(EMIF_PHYCFG, EMIF4_1_DDR_PHY_CTRL_1);
-	__raw_writel(EMIF_PHYCFG, EMIF4_1_DDR_PHY_CTRL_1_SHADOW);
 	}
 
-}
 
-static void update_dqs(int emif)
-{
 }
 
 static void config_ti816x_sdram_ddr(void)
 {
 	__raw_writel(0x2, CM_DEFAULT_L3_FAST_CLKSTCTRL);			/*Enable the Power Domain Transition of L3 Fast Domain Peripheral*/
 	__raw_writel(0x2, CM_DEFAULT_EMIF_0_CLKCTRL);				/*Enable EMIF0 Clock*/
-	__raw_writel(0x2, CM_DEFAULT_EMIF_1_CLKCTRL); 				/*Enable EMIF1 Clock*/
+	__raw_writel(0x2, CM_DEFAULT_EMIF_1_CLKCTRL);				/*Enable EMIF1 Clock*/
 	while((__raw_readl(CM_DEFAULT_L3_FAST_CLKSTCTRL) & 0x300) != 0x300);	/*Poll for L3_FAST_GCLK  & DDR_GCLK  are active*/
 	while((__raw_readl(CM_DEFAULT_EMIF_0_CLKCTRL)) != 0x2);	/*Poll for Module is functional*/
 	while((__raw_readl(CM_DEFAULT_EMIF_1_CLKCTRL)) != 0x2);	/*Poll for Module is functional*/
@@ -628,24 +687,27 @@ static void config_ti816x_sdram_ddr(void)
 		ddr_init_settings(1);
 	}
 
-	__raw_writel(0x2, CM_DEFAULT_DMM_CLKCTRL); 				/*Enable EMIF1 Clock*/
+	__raw_writel(0x2, CM_DEFAULT_DMM_CLKCTRL);				/*Enable EMIF1 Clock*/
 	while((__raw_readl(CM_DEFAULT_DMM_CLKCTRL)) != 0x2);		/*Poll for Module is functional*/
 
-	/*Program the DMM to Access EMIF0*/
+#if 0
+	/* Program the DMM for non-interleave setting */
+	__raw_writel(0x0, DMM_LISA_MAP__0);
+	__raw_writel(0x0, DMM_LISA_MAP__1);
+	__raw_writel(0x80500100, DMM_LISA_MAP__2);
+	__raw_writel(0xA0500200, DMM_LISA_MAP__3);
+#endif
+
+	/*Program the DMM for interleave setting */
 	__raw_writel(0x80640300, DMM_LISA_MAP__0);
 	__raw_writel(0xC0640320, DMM_LISA_MAP__1);
-
-	/*Program the DMM to Access EMIF1*/
 	__raw_writel(0x80640300, DMM_LISA_MAP__2);
 	__raw_writel(0xC0640320, DMM_LISA_MAP__3);
 
 	/*Enable Tiled Access*/
 	__raw_writel(0x80000000, DMM_PAT_BASE_ADDR);
 
-	emif4p_init(EMIF_TIM1, EMIF_TIM2, EMIF_TIM3, EMIF_SDREF & 0xFFFFFFFF, EMIF_SDCFG, 0x10B);
-	ddrsetup();
-	update_dqs(0);
-	update_dqs(1);
+	emif4p_init(EMIF_TIM1, EMIF_TIM2, EMIF_TIM3, EMIF_SDREF & 0xFFFFFFF, EMIF_SDCFG, EMIF_PHYCFG);
 }
 #endif
 
@@ -820,7 +882,7 @@ int misc_init_r (void)
 	return 0;
 }
 
-#ifdef CONFIG_TI816X_EVM_DDR3
+#ifdef CONFIG_TI816X_DDR3_PG_1_0
 void walking_one_test(unsigned long start_addr, unsigned long end_addr)
 {
 	data_walking_test(start_addr, 0xffffffff);
@@ -971,6 +1033,9 @@ void prcm_init(u32 in_ddr)
 	/* Enable the control module */
 	__raw_writel(0x2, CM_ALWON_CONTROL_CLKCTRL);
 
+	/* Fix ROM code bug */
+	__raw_writel(0x0, 0x48180324);
+
 	//if (is_cpu_family() == CPU_TI816X) {
 		main_pll_init_ti816x(clk_index, sil_index);
 		if (!in_ddr)
@@ -1004,6 +1069,17 @@ void set_muxconf_regs(void)
 void s_init(u32 in_ddr)
 {
 	l2_cache_enable();		/* Can be removed as A8 comes up with L2 enabled */
+#ifdef CONFIG_SETUP_1V
+	__raw_writel(0x102, 0x4818155c);
+	while((__raw_readl(0x4818155c) & 0x3) != 0x2);
+
+	__raw_writel(0x102, 0x48181560);
+	while((__raw_readl(0x48181560) & 0x3) != 0x2);
+
+	__raw_writel(0x00000001, 0x4803213c);
+	__raw_writel(0xfffffff0, 0x48032134);
+#endif
+
 	prcm_init(in_ddr);			/* Setup the PLLs and the clocks for the peripherals */
 	set_muxconf_regs();
 	if (!in_ddr)
diff --git a/include/configs/ti8168_evm.h b/include/configs/ti8168_evm.h
index a0a7f4c..ccaf9dd 100644
--- a/include/configs/ti8168_evm.h
+++ b/include/configs/ti8168_evm.h
@@ -23,6 +23,7 @@
 /* Display CPU info */
 #define CONFIG_DISPLAY_CPUINFO		1
 
+//#define CONFIG_SETUP_1V
 /*
  * Size of malloc() pool
  */
@@ -32,8 +33,8 @@
 						   initial data */
 
 /* Only one the following two options (DDR3/DDR2) should be enabled */
-//#define CONFIG_TI816X_EVM_DDR3			/* Configure DDR3 in U-Boot */
-#define CONFIG_TI816X_EVM_DDR2				/* Configure DDR2 in U-Boot */
+#define CONFIG_TI816X_EVM_DDR3			/* Configure DDR3 in U-Boot */
+//#define CONFIG_TI816X_EVM_DDR2				/* Configure DDR2 in U-Boot */
 #define CONFIG_TI816X_TWO_EMIF		1
 #define CONFIG_MISC_INIT_R		1
 #define CONFIG_TI816X_ASCIIART		1	/* The eye */
-- 
1.6.2.4

