From 93c8b63af2c5b55a7281037f18e13b8381b25ab1 Mon Sep 17 00:00:00 2001
From: Don Darling <don.osc2@gmail.com>
Date: Thu, 11 Mar 2010 13:10:26 -0600
Subject: [PATCH 2/9] Support for non-standard colorspaces and custom V4L2 ioctls on TI LSPs.

---
 sys/v4l2/Makefile.am         |    4 +-
 sys/v4l2/Makefile.in         |   10 +
 sys/v4l2/gstv4l2bufferpool.c |    4 +
 sys/v4l2/gstv4l2bufferpool.h |    3 +
 sys/v4l2/gstv4l2object.c     |   60 +++++-
 sys/v4l2/gstv4l2object.h     |    9 +
 sys/v4l2/gstv4l2src.c        |   37 +++-
 sys/v4l2/v4l2_calls.c        |   18 ++
 sys/v4l2/v4l2src_calls.c     |   10 +
 sys/v4l2/v4l2src_davinci.c   |  494 ++++++++++++++++++++++++++++++++++++++++++
 sys/v4l2/v4l2src_davinci.h   |   55 +++++
 11 files changed, 700 insertions(+), 4 deletions(-)
 create mode 100644 sys/v4l2/v4l2src_davinci.c
 create mode 100644 sys/v4l2/v4l2src_davinci.h

diff --git a/sys/v4l2/Makefile.am b/sys/v4l2/Makefile.am
index e655bcb..965883b 100644
--- a/sys/v4l2/Makefile.am
+++ b/sys/v4l2/Makefile.am
@@ -19,6 +19,7 @@ libgstvideo4linux2_la_SOURCES = gstv4l2.c \
 				gstv4l2vidorient.c \
 				v4l2_calls.c \
 				v4l2src_calls.c \
+                v4l2src_davinci.c \
 				$(xv_source)
 
 libgstvideo4linux2_la_CFLAGS =   $(GST_PLUGINS_BASE_CFLAGS) \
@@ -50,4 +51,5 @@ noinst_HEADERS = \
 	gstv4l2vidorient.h \
 	gstv4l2xoverlay.h \
 	v4l2_calls.h \
-	v4l2src_calls.h
+	v4l2src_calls.h \
+    v4l2src_davinci.h 
diff --git a/sys/v4l2/Makefile.in b/sys/v4l2/Makefile.in
index 2663df8..90ae2a3 100644
--- a/sys/v4l2/Makefile.in
+++ b/sys/v4l2/Makefile.in
@@ -100,6 +100,7 @@ am_libgstvideo4linux2_la_OBJECTS = libgstvideo4linux2_la-gstv4l2.lo \
 	libgstvideo4linux2_la-gstv4l2tuner.lo \
 	libgstvideo4linux2_la-gstv4l2vidorient.lo \
 	libgstvideo4linux2_la-v4l2_calls.lo \
+	libgstvideo4linux2_la-v4l2src_davinci.lo \
 	libgstvideo4linux2_la-v4l2src_calls.lo
 libgstvideo4linux2_la_OBJECTS = $(am_libgstvideo4linux2_la_OBJECTS)
 libgstvideo4linux2_la_LINK = $(LIBTOOL) --tag=CC \
@@ -457,6 +458,7 @@ libgstvideo4linux2_la_SOURCES = gstv4l2.c \
 				gstv4l2tuner.c \
 				gstv4l2vidorient.c \
 				v4l2_calls.c \
+				v4l2src_davinci.c \
 				v4l2src_calls.c \
 				$(xv_source)
 
@@ -488,6 +490,7 @@ noinst_HEADERS = \
 	gstv4l2vidorient.h \
 	gstv4l2xoverlay.h \
 	v4l2_calls.h \
+	v4l2src_davinci.h \
 	v4l2src_calls.h
 
 all: all-am
@@ -654,6 +657,13 @@ libgstvideo4linux2_la-v4l2_calls.lo: v4l2_calls.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -c -o libgstvideo4linux2_la-v4l2_calls.lo `test -f 'v4l2_calls.c' || echo '$(srcdir)/'`v4l2_calls.c
 
+libgstvideo4linux2_la-v4l2src_davinci.lo: v4l2src_davinci.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -MT libgstvideo4linux2_la-v4l2src_davinci.lo -MD -MP -MF $(DEPDIR)/libgstvideo4linux2_la-v4l2src_davinci.Tpo -c -o libgstvideo4linux2_la-v4l2src_davinci.lo `test -f 'v4l2src_davinci.c' || echo '$(srcdir)/'`v4l2src_davinci.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libgstvideo4linux2_la-v4l2src_davinci.Tpo $(DEPDIR)/libgstvideo4linux2_la-v4l2src_davinci.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='v4l2src_davinci.c' object='libgstvideo4linux2_la-v4l2src_davinci.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -c -o libgstvideo4linux2_la-v4l2src_davinci.lo `test -f 'v4l2src_davinci.c' || echo '$(srcdir)/'`v4l2src_davinci.c
+
 libgstvideo4linux2_la-v4l2src_calls.lo: v4l2src_calls.c
 @am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(libgstvideo4linux2_la_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgstvideo4linux2_la_CFLAGS) $(CFLAGS) -MT libgstvideo4linux2_la-v4l2src_calls.lo -MD -MP -MF $(DEPDIR)/libgstvideo4linux2_la-v4l2src_calls.Tpo -c -o libgstvideo4linux2_la-v4l2src_calls.lo `test -f 'v4l2src_calls.c' || echo '$(srcdir)/'`v4l2src_calls.c
 @am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libgstvideo4linux2_la-v4l2src_calls.Tpo $(DEPDIR)/libgstvideo4linux2_la-v4l2src_calls.Plo
diff --git a/sys/v4l2/gstv4l2bufferpool.c b/sys/v4l2/gstv4l2bufferpool.c
index 494f46d..b85d420 100644
--- a/sys/v4l2/gstv4l2bufferpool.c
+++ b/sys/v4l2/gstv4l2bufferpool.c
@@ -531,7 +531,11 @@ gst_v4l2_buffer_pool_dqbuf (GstV4l2BufferPool * pool)
     GST_V4L2_BUFFER_POOL_UNLOCK (pool);
 
     /* this can change at every frame, esp. with jpeg */
+#if defined(DAVINCI_LSP_WORKAROUND) && ( defined(Platform_dm6467) || defined(Platform_dm357))
+    GST_BUFFER_SIZE (pool_buffer) = pool->bytesused;
+#else    
     GST_BUFFER_SIZE (pool_buffer) = buffer.bytesused;
+#endif
 
     return pool_buffer;
   }
diff --git a/sys/v4l2/gstv4l2bufferpool.h b/sys/v4l2/gstv4l2bufferpool.h
index 36a4220..789ccea 100644
--- a/sys/v4l2/gstv4l2bufferpool.h
+++ b/sys/v4l2/gstv4l2bufferpool.h
@@ -64,6 +64,9 @@ struct _GstV4l2BufferPool
   gint video_fd;             /* a dup(2) of the v4l2object's video_fd */
   guint buffer_count;
   GstV4l2Buffer **buffers;
+  #if defined(DAVINCI_LSP_WORKAROUND)
+  guint32 bytesused;
+  #endif
 };
 
 struct _GstV4l2Buffer {
diff --git a/sys/v4l2/gstv4l2object.c b/sys/v4l2/gstv4l2object.c
index f73ce21..1aad474 100644
--- a/sys/v4l2/gstv4l2object.c
+++ b/sys/v4l2/gstv4l2object.c
@@ -41,6 +41,9 @@
 
 #include "gst/gst-i18n-plugin.h"
 
+#if defined(DAVINCI_LSP_WORKAROUND)
+#include "v4l2src_davinci.h"
+#endif
 
 GST_DEBUG_CATEGORY_EXTERN (v4l2_debug);
 #define GST_CAT_DEFAULT v4l2_debug
@@ -673,6 +676,9 @@ static const guint32 gst_v4l2_formats[] = {
 #ifdef V4L2_PIX_FMT_YVYU
   V4L2_PIX_FMT_YVYU,
 #endif
+#ifdef V4L2_PIX_FMT_YUV422UVP
+   V4L2_PIX_FMT_YUV422UVP
+#endif
 };
 
 #define GST_V4L2_FORMAT_COUNT (G_N_ELEMENTS (gst_v4l2_formats))
@@ -1004,6 +1010,9 @@ gst_v4l2_object_v4l2fourcc_to_structure (guint32 fourcc)
 #ifdef V4L2_PIX_FMT_YVYU
     case V4L2_PIX_FMT_YVYU:
 #endif
+#ifdef V4L2_PIX_FMT_YUV422UVP
+    case V4L2_PIX_FMT_YUV422UVP:
+#endif
     case V4L2_PIX_FMT_YUV411P:{
       guint32 fcc = 0;
 
@@ -1046,6 +1055,11 @@ gst_v4l2_object_v4l2fourcc_to_structure (guint32 fourcc)
           fcc = GST_MAKE_FOURCC ('Y', 'V', 'Y', 'U');
           break;
 #endif
+#ifdef V4L2_PIX_FMT_YUV422UVP
+       case V4L2_PIX_FMT_YUV422UVP:
+         fcc = GST_MAKE_FOURCC ('Y', '8', 'C', '8');
+         break;
+#endif
         default:
           g_assert_not_reached ();
           break;
@@ -1200,8 +1214,14 @@ gst_v4l2_object_get_caps_info (GstV4l2Object * v4l2object, GstCaps * caps,
         break;
       case GST_MAKE_FOURCC ('N', 'V', '1', '2'):
         fourcc = V4L2_PIX_FMT_NV12;
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+        /* NV12 buffer on dm365 is 32-byte aligned */
+        outsize = GST_ROUND_UP_32 (*w) * GST_ROUND_UP_2 (*h);
+        outsize += (GST_ROUND_UP_32 (*w) * *h) / 2;
+#else
         outsize = GST_ROUND_UP_4 (*w) * GST_ROUND_UP_2 (*h);
         outsize += (GST_ROUND_UP_4 (*w) * *h) / 2;
+#endif
         break;
       case GST_MAKE_FOURCC ('N', 'V', '2', '1'):
         fourcc = V4L2_PIX_FMT_NV21;
@@ -1651,6 +1671,12 @@ default_frame_sizes:
     gint min_w, max_w, min_h, max_h, fix_num = 0, fix_denom = 0;
 
     /* This code is for Linux < 2.6.19 */
+#if defined(DAVINCI_LSP_WORKAROUND)
+    gst_v4l2src_get_resolution(v4l2object, &min_w, &min_h, &fix_num, 
+        &fix_denom); 
+    gst_v4l2src_get_resolution(v4l2object, &max_w, &max_h, &fix_num, 
+        &fix_denom);
+#else
     min_w = min_h = 1;
     max_w = max_h = GST_V4L2_MAX_SIZE;
     if (!gst_v4l2_object_get_nearest_size (v4l2object, pixelformat, &min_w,
@@ -1665,7 +1691,8 @@ default_frame_sizes:
           "Could not probe maximum capture size for pixelformat %"
           GST_FOURCC_FORMAT, GST_FOURCC_ARGS (pixelformat));
     }
-
+#endif
+   
     /* Since we can't get framerate directly, try to use the current norm */
     if (v4l2object->norm && v4l2object->norms) {
       GList *norms;
@@ -1678,8 +1705,10 @@ default_frame_sizes:
       }
       /* If it's possible, set framerate to that (discrete) value */
       if (norm) {
+#if !defined(DAVINCI_LSP_WORKAROUND)
         fix_num = gst_value_get_fraction_numerator (&norm->framerate);
         fix_denom = gst_value_get_fraction_denominator (&norm->framerate);
+#endif
       }
     }
 
@@ -1798,6 +1827,13 @@ gst_v4l2_object_set_format (GstV4l2Object * v4l2object, guint32 pixelformat,
   GST_V4L2_CHECK_OPEN (v4l2object);
   GST_V4L2_CHECK_NOT_ACTIVE (v4l2object);
 
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+  if (pixelformat != V4L2_PIX_FMT_NV12) {
+    GST_INFO("closing ipipe module\n");
+    dm365_resize_destroy(v4l2object);
+  }
+#endif
+
   memset (&format, 0x00, sizeof (struct v4l2_format));
   format.type = v4l2object->type;
 
@@ -1811,7 +1847,29 @@ gst_v4l2_object_set_format (GstV4l2Object * v4l2object, guint32 pixelformat,
   /* request whole frames; change when gstreamer supports interlaced video
    * (INTERLACED mode returns frames where the fields have already been
    *  combined, there are other modes for requesting fields individually) */
+#if defined(DAVINCI_LSP_WORKAROUND) && !defined(Platform_dm6467)
   format.fmt.pix.field = V4L2_FIELD_INTERLACED;
+#endif
+
+#if defined(DAVINCI_LSP_WORKAROUND)
+  v4l2object->bytesused = format.fmt.pix.sizeimage;
+#endif
+
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+  if(v4l2object->input_src) {
+    if (!strcmp(v4l2object->input_src, "component"))
+        format.fmt.pix.field = V4L2_FIELD_NONE;
+    else
+        format.fmt.pix.field = V4L2_FIELD_INTERLACED;
+  }
+  else
+        format.fmt.pix.field = V4L2_FIELD_NONE;
+
+  if (v4l2_ioctl (fd, VIDIOC_TRY_FMT, &format) < 0) {
+    if (errno != EINVAL)
+      goto set_fmt_failed;
+  }
+#endif
 
   if (v4l2_ioctl (fd, VIDIOC_S_FMT, &format) < 0) {
     if (errno != EINVAL)
diff --git a/sys/v4l2/gstv4l2object.h b/sys/v4l2/gstv4l2object.h
index 4aac3a5..67aff0d 100644
--- a/sys/v4l2/gstv4l2object.h
+++ b/sys/v4l2/gstv4l2object.h
@@ -118,6 +118,15 @@ struct _GstV4l2Object {
   GstV4l2GetInOutFunction  get_in_out_func;
   GstV4l2SetInOutFunction  set_in_out_func;
   GstV4l2UpdateFpsFunction update_fps_func;
+
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+  gchar *input_src;
+  gboolean force_720p_30;
+#endif
+#if defined(DAVINCI_LSP_WORKAROUND)
+  guint32 bytesused;
+#endif
+
 };
 
 struct _GstV4l2ObjectClassHelper {
diff --git a/sys/v4l2/gstv4l2src.c b/sys/v4l2/gstv4l2src.c
index 463bef3..3c2b9c2 100644
--- a/sys/v4l2/gstv4l2src.c
+++ b/sys/v4l2/gstv4l2src.c
@@ -79,7 +79,11 @@ enum
   PROP_0,
   V4L2_STD_OBJECT_PROPS,
   PROP_QUEUE_SIZE,
-  PROP_ALWAYS_COPY
+  PROP_ALWAYS_COPY,
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+  PROP_INPUT_SRC,
+  PROP_FORCE_720P_30,
+#endif
 };
 
 GST_IMPLEMENT_V4L2_PROBE_METHODS (GstV4l2SrcClass, gst_v4l2src);
@@ -252,7 +256,16 @@ gst_v4l2src_class_init (GstV4l2SrcClass * klass)
       g_param_spec_boolean ("always-copy", "Always Copy",
           "If the buffer will or not be used directly from mmap",
           PROP_DEF_ALWAYS_COPY, G_PARAM_READWRITE));
-
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+  g_object_class_install_property (gobject_class, PROP_INPUT_SRC,
+      g_param_spec_string ("input-src", "Select the input source",
+          "Select the input source (composite, component, svideo)",
+          NULL, G_PARAM_READWRITE));
+  g_object_class_install_property (gobject_class, PROP_FORCE_720P_30,
+      g_param_spec_boolean ("force-720p-30", "Configure 720P @ 30fps",
+          "Force driver to work on 720P @ 30fps",
+          FALSE, G_PARAM_READWRITE));
+#endif
   basesrc_class->get_caps = GST_DEBUG_FUNCPTR (gst_v4l2src_get_caps);
   basesrc_class->set_caps = GST_DEBUG_FUNCPTR (gst_v4l2src_set_caps);
   basesrc_class->start = GST_DEBUG_FUNCPTR (gst_v4l2src_start);
@@ -280,6 +293,10 @@ gst_v4l2src_init (GstV4l2Src * v4l2src, GstV4l2SrcClass * klass)
   v4l2src->always_copy = PROP_DEF_ALWAYS_COPY;
 
   v4l2src->is_capturing = FALSE;
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+  v4l2src->v4l2object->input_src = NULL;
+  v4l2src->v4l2object->force_720p_30 = FALSE;
+#endif
 
   gst_base_src_set_format (GST_BASE_SRC (v4l2src), GST_FORMAT_TIME);
   gst_base_src_set_live (GST_BASE_SRC (v4l2src), TRUE);
@@ -326,6 +343,14 @@ gst_v4l2src_set_property (GObject * object,
       case PROP_ALWAYS_COPY:
         v4l2src->always_copy = g_value_get_boolean (value);
         break;
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+      case PROP_INPUT_SRC:
+        v4l2src->v4l2object->input_src = g_strdup(g_value_get_string(value));
+        break;
+      case PROP_FORCE_720P_30:
+        v4l2src->v4l2object->force_720p_30 = g_value_get_boolean (value);
+        break;
+#endif
       default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
@@ -349,6 +374,14 @@ gst_v4l2src_get_property (GObject * object,
       case PROP_ALWAYS_COPY:
         g_value_set_boolean (value, v4l2src->always_copy);
         break;
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+      case PROP_INPUT_SRC:
+        g_value_set_string(value, v4l2src->v4l2object->input_src);
+        break;
+      case PROP_FORCE_720P_30:
+        g_value_set_boolean (value, v4l2src->v4l2object->force_720p_30);
+        break;
+#endif
       default:
         G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
         break;
diff --git a/sys/v4l2/v4l2_calls.c b/sys/v4l2/v4l2_calls.c
index 5f6261e..1d0447a 100644
--- a/sys/v4l2/v4l2_calls.c
+++ b/sys/v4l2/v4l2_calls.c
@@ -50,6 +50,10 @@
 
 #include "gst/gst-i18n-plugin.h"
 
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+#include "v4l2src_davinci.h"
+#endif
+
 /* Those are ioctl calls */
 #ifndef V4L2_CID_HCENTER
 #define V4L2_CID_HCENTER V4L2_CID_HCENTER_DEPRECATED
@@ -410,6 +414,14 @@ gst_v4l2_open (GstV4l2Object * v4l2object)
   int libv4l2_fd;
   GstPollFD pollfd = GST_POLL_FD_INIT;
 
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+   GST_DEBUG_OBJECT(v4l2object->element, 
+        "Opening IPIPE module (rsz+prev) to enable NV12\n");
+   if (dm365_resize_create(v4l2object) < 0) {
+     GST_ERROR("failed to create ipipe handle\n");
+   }
+#endif
+
   GST_DEBUG_OBJECT (v4l2object->element, "Trying to open device %s",
       v4l2object->videodev);
 
@@ -548,6 +560,12 @@ gst_v4l2_close (GstV4l2Object * v4l2object)
   gst_poll_remove_fd (v4l2object->poll, &pollfd);
   v4l2object->video_fd = -1;
 
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+  if (dm365_resize_destroy(v4l2object) < 0) {
+    GST_LOG("failed to close ipipe module\n");
+  }
+#endif
+
   /* empty lists */
   gst_v4l2_empty_lists (v4l2object);
 
diff --git a/sys/v4l2/v4l2src_calls.c b/sys/v4l2/v4l2src_calls.c
index d8e365f..1b7385b 100644
--- a/sys/v4l2/v4l2src_calls.c
+++ b/sys/v4l2/v4l2src_calls.c
@@ -105,6 +105,10 @@ gst_v4l2src_grab_frame (GstV4l2Src * v4l2src, GstBuffer ** buf)
   v4l2object = v4l2src->v4l2object;
   pool = v4l2src->pool;
 
+  #if defined(DAVINCI_LSP_WORKAROUND)
+  pool->bytesused = v4l2src->v4l2object->bytesused;
+  #endif
+
   GST_DEBUG_OBJECT (v4l2src, "grab frame");
 
   for (;;) {
@@ -342,6 +346,12 @@ gst_v4l2src_capture_start (GstV4l2Src * v4l2src)
   v4l2src->quit = FALSE;
 
   if (v4l2src->use_mmap) {
+#if defined(DAVINCI_LSP_WORKAROUND) && defined(Platform_dm365)
+    if (v4l2src->v4l2object->force_720p_30) {
+        if (!gst_v4l2_force_720p_30(v4l2src))
+            return FALSE;
+    }
+#endif
     if (!gst_v4l2src_buffer_pool_activate (v4l2src->pool, v4l2src)) {
       return FALSE;
     }
diff --git a/sys/v4l2/v4l2src_davinci.c b/sys/v4l2/v4l2src_davinci.c
new file mode 100644
index 0000000..75e412d
--- /dev/null
+++ b/sys/v4l2/v4l2src_davinci.c
@@ -0,0 +1,494 @@
+/*
+ * v4l2src_davinci.c
+ *
+ * This file defines functions needed to get v4l2src on dm6446, dm355, dm6467
+ * , dm357 and dm365 LSP's.
+ *
+ *
+ * Most the code is copied from DMAI capture routines with following license:
+ *
+ * --COPYRIGHT--,BSD
+ * Copyright (c) 2009, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#ifdef __sun
+/* Needed on older Solaris Nevada builds (72 at least) */
+#include <stropts.h>
+#include <sys/ioccom.h>
+#endif
+
+#include "v4l2src_davinci.h"
+
+#if defined(DAVINCI_LSP_WORKAROUND)
+void gst_v4l2src_convert_to_upper (char *str)
+{
+    int ch, i;
+    if (str == NULL)
+        return;
+  
+    for(i=0; i<strlen(str); i++) {
+        ch = toupper(str[i]);
+        str[i]  = ch;
+    }
+}
+
+/******************************************************
+ * gst_v4l2src_get_resolution
+ *   get the video resolution
+ *****************************************************/
+void  gst_v4l2src_get_resolution (GstV4l2Object *v4l2object, gint *width, gint *height, gint *fps_num, gint *fps_denom)
+{
+  gint fd = v4l2object->video_fd;
+  v4l2_std_id  std;
+  gint failCount = 0, ret;
+  
+  #if defined(Platform_dm365) 
+  struct v4l2_input  v4l2Input;
+  int input, queryInput, idx;
+  char *strings[6] = {"RAW", "RAW-1", "COMPOSITE", "SVIDEO", "COMPONENT" };
+
+  gst_v4l2src_convert_to_upper(v4l2object->input_src); 
+  
+  v4l2Input.type = V4L2_INPUT_TYPE_CAMERA;
+  v4l2Input.index = 0;
+  GST_LOG ("Enumerating video inputs\n");
+  do {
+    idx = v4l2Input.index;
+    if (ioctl(fd, VIDIOC_ENUMINPUT, &v4l2Input) < 0) {
+        if (errno == EINVAL || errno == ENOTTY)
+            break;
+    }
+
+    if (v4l2object->input_src && !strcmp(v4l2object->input_src, strings[idx])) {
+        break;
+    }
+    v4l2Input.index++;
+
+  }while(1);
+
+  input = v4l2Input.index;
+  GST_LOG("setting index=%d, name=%s\n", v4l2Input.index, v4l2Input.name);
+
+  ioctl(fd, VIDIOC_S_INPUT, &input);
+  ioctl(fd, VIDIOC_G_INPUT, &queryInput);
+  #endif  
+
+  do {
+    ret = ioctl(fd, VIDIOC_QUERYSTD, &std);
+    if (ret == -1 && errno == EAGAIN) {
+        usleep(1);
+        failCount++;
+    }
+  }while(ret == -1 && errno == EAGAIN && failCount < 5);
+
+  if (ret == -1) { 
+    GST_ERROR("failed to query standard, Video input connected ?\n");
+  }
+
+  /* It might take a few tries to detect the signal */
+  if (std & V4L2_STD_NTSC) {
+    GST_LOG("found ntsc standard\n");
+    *width = 720;
+    *height = 480;
+    *fps_num = 30000;
+    *fps_denom = 1001;
+  }
+  else if (std & V4L2_STD_PAL) {
+    GST_LOG("found pal standard\n");
+    *width = 720;
+    *height = 576;
+    *fps_num = 25;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_525P_60) {
+    GST_LOG("found 525p standard\n");
+    *width = 720;
+    *height = 480;
+    *fps_num = 30000;
+    *fps_denom = 1001;
+  }
+  else if (std & V4L2_STD_625P_50) {
+    GST_LOG("found 625p standard\n");
+    *width = 720;
+    *height = 576;
+    *fps_num = 25;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_720P_60) {
+    GST_LOG("found 720p @60fps standard\n");
+    *width = 1280;
+    *height = 720;
+    *fps_num = 60;
+    *fps_denom = 1;
+    #if defined(Platform_dm365)
+    if (v4l2object->force_720p_30) {
+        *fps_num = 30000;
+        *fps_denom = 1001;
+    }
+    #endif
+  }
+  else if (std & V4L2_STD_720P_50) {
+    GST_LOG("found 720p @50fps standard\n");
+    *width = 1280;
+    *height = 720;
+    *fps_num = 50;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080I_60) {
+    GST_LOG("found 1080i @60fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 60;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080I_50) {
+    GST_LOG("found 1080i @50fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 50;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080P_30) {
+    GST_LOG("found 1080p @30fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 30;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080P_25) {
+    GST_LOG("found 1080p @25fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 25;
+    *fps_denom = 1;
+  }
+  else if (std & V4L2_STD_1080P_24) {
+    GST_LOG("found 1080p @24fps standard\n");
+    *width = 1920;
+    *height = 1080;
+    *fps_num = 24;
+    *fps_denom = 1;
+  }
+  else {
+    GST_WARNING("failed to detect video standard\n");
+    *width = 1;
+    *height = 1;
+    *fps_num = 1;
+    *fps_denom = 1;
+  }
+}
+
+#if defined(Platform_dm365)
+#include <asm/arch/imp_resizer.h>
+#include <asm/arch/imp_previewer.h>
+#include <asm/arch/dm365_ipipe.h>
+
+#define RESIZER_DEVICE   "/dev/davinci_resizer"
+#define PREVIEWER_DEVICE "/dev/davinci_previewer"
+
+/* resizer and previewer file descriptors */
+static gint resizer_fd   = -1;
+static gint previewer_fd = -1;
+
+/******************************************************
+ * gst_v4l2src_force_720p_30
+ *****************************************************/
+gboolean gst_v4l2_force_720p_30 (GstV4l2Src * v4l2src)
+{
+  gint fd = v4l2src->v4l2object->video_fd;
+  struct v4l2_standard   stdinfo;        
+  struct v4l2_streamparm streamparam, streamparam_s;
+  gboolean                   found;
+
+  stdinfo.index = 0;
+  found = 0;
+  while ( 0 == ioctl(fd, VIDIOC_ENUMSTD, &stdinfo)) {
+    if (stdinfo.id == V4L2_STD_720P_60) {
+        found = 1;
+        break;
+    }
+    stdinfo.index++;
+  }
+
+  if (found) {
+    /* set the streaming parameter to reduce the capture frequency to half */
+    streamparam.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    streamparam.parm.capture.timeperframe.numerator = 
+        stdinfo.frameperiod.numerator;
+    streamparam.parm.capture.timeperframe.denominator =
+        stdinfo.frameperiod.denominator / 2;    
+    streamparam_s = streamparam;
+    if (ioctl(fd, VIDIOC_S_PARM , &streamparam) < 0 ) {
+        GST_ERROR("failed to VIDIOC_S_PARM\n");
+        return FALSE;
+    }
+
+    /* verify the params */
+    if (ioctl(fd, VIDIOC_G_PARM, &streamparam) < 0) {
+        GST_ERROR("VIDIOC_G_PARM failed\n");
+        return FALSE;
+    }
+
+    if ((streamparam.parm.capture.timeperframe.numerator != 
+        streamparam_s.parm.capture.timeperframe.numerator) ||
+        (streamparam.parm.capture.timeperframe.denominator !=
+            streamparam_s.parm.capture.timeperframe.denominator)) {
+            GST_ERROR("Could not set capture driver for 30fps\n");
+            return FALSE;            
+    }
+  }
+
+  GST_ELEMENT_WARNING(v4l2src, RESOURCE, WRITE, ("forcing from 720P @60fps to "
+    "720P @30fps\n"), (NULL));
+  return TRUE;
+}
+
+static gint
+gst_v4l2_setresize_continuous(void)
+{
+    gint rsz_fd;
+    unsigned int oper_mode, user_mode;
+    struct rsz_channel_config rsz_chan_config;
+    struct rsz_continuous_config rsz_cont_config;
+
+    user_mode = IMP_MODE_CONTINUOUS;
+    rsz_fd = open((const char *)RESIZER_DEVICE, O_RDWR);
+    if (rsz_fd <= 0) {
+        GST_DEBUG ("Failed to open resizer device %s", RESIZER_DEVICE);
+        return -1;
+    }
+
+    if (ioctl(rsz_fd, RSZ_S_OPER_MODE, &user_mode) < 0) {
+        GST_DEBUG ("Can't set operation mode (%s)\n", strerror(errno));
+        close(rsz_fd);
+        return -1;
+    }
+
+    if (ioctl(rsz_fd, RSZ_G_OPER_MODE, &oper_mode) < 0) {
+        GST_DEBUG ("Can't get operation mode (%s)\n", strerror(errno));
+        close(rsz_fd);
+        return -1;
+    }
+
+    if (oper_mode == user_mode) {
+        GST_DEBUG ("Successfully set mode to continuous in resizer\n");
+    }
+    else {
+        GST_DEBUG ("Failed to set mode to continuous in resizer\n");
+        close(rsz_fd);
+        return -1;
+    }
+
+    /* set configuration to chain resizer with preview */
+    rsz_chan_config.oper_mode = user_mode;
+    rsz_chan_config.chain  = 1;
+    rsz_chan_config.len = 0;
+    rsz_chan_config.config = NULL; /* to set defaults in driver */
+    if (ioctl(rsz_fd, RSZ_S_CONFIG, &rsz_chan_config) < 0) {
+        GST_DEBUG ("Error in setting default configuration in resizer (%s)\n",
+            strerror(errno));
+        close(rsz_fd);
+        return -1;
+    }
+
+    bzero(&rsz_cont_config, sizeof(struct rsz_continuous_config));
+    rsz_chan_config.oper_mode = user_mode;
+    rsz_chan_config.chain = 1;
+    rsz_chan_config.len = sizeof(struct rsz_continuous_config);
+    rsz_chan_config.config = &rsz_cont_config;
+
+    if (ioctl(rsz_fd, RSZ_G_CONFIG, &rsz_chan_config) < 0) {
+        GST_DEBUG ("Error in getting channel configuration from resizer (%s)\n",
+            strerror(errno));
+        close(rsz_fd);
+        return -1;
+    }
+
+    /* we can ignore the input spec since we are chaining. So only set output
+     * specs
+     */
+    rsz_cont_config.output1.enable  = 1;
+    rsz_cont_config.output2.enable  = 0;
+    rsz_chan_config.len = sizeof(struct rsz_continuous_config);
+    rsz_chan_config.config = &rsz_cont_config;
+    if (ioctl(rsz_fd, RSZ_S_CONFIG, &rsz_chan_config) < 0) {
+        GST_DEBUG ("Error in setting resizer configuration (%s)\n",
+                    strerror(errno));
+        close(rsz_fd);
+        return -1;
+    }
+
+    GST_DEBUG ("Resizer initialized\n");
+    return rsz_fd;
+}
+
+static gint
+gst_v4l2_setpreview_continuous(void)
+{
+    gint preview_fd;
+    unsigned int oper_mode, user_mode;
+    struct prev_channel_config prev_chan_config;
+    struct prev_continuous_config prev_cont_config;
+
+    user_mode = IMP_MODE_CONTINUOUS;
+
+    preview_fd = open((const char *)PREVIEWER_DEVICE, O_RDWR);
+    if (preview_fd <= 0) {
+        GST_DEBUG ("Cannot open previewer device \n");
+        return -1;
+    }
+
+    if (ioctl(preview_fd,PREV_S_OPER_MODE, &user_mode) < 0) {
+        GST_DEBUG ("Can't set operation mode in previewer (%s)\n",
+                    strerror(errno));
+        close(preview_fd);
+        return -1;
+    }
+
+    if (ioctl(preview_fd,PREV_G_OPER_MODE, &oper_mode) < 0) {
+        GST_DEBUG ("Can't get operation mode from previewer (%s)\n",
+                    strerror(errno));
+        close(preview_fd);
+        return -1;
+    }
+
+    if (oper_mode == user_mode) {
+        GST_DEBUG ("Operating mode changed successfully to continuous"
+                   " in previewer");
+    }
+    else {
+        GST_DEBUG ("failed to set mode to continuous in previewer\n");
+        close(preview_fd);
+        return -1;
+    }
+
+    prev_chan_config.oper_mode = oper_mode;
+    prev_chan_config.len = 0;
+    prev_chan_config.config = NULL; /* to set defaults in driver */
+    if (ioctl(preview_fd, PREV_S_CONFIG, &prev_chan_config) < 0) {
+        GST_DEBUG ("Error in setting default previewer configuration (%s)\n",
+            strerror(errno));
+        close(preview_fd);
+        return -1;
+    }
+
+    prev_chan_config.oper_mode = oper_mode;
+    prev_chan_config.len = sizeof(struct prev_continuous_config);
+    prev_chan_config.config = &prev_cont_config;
+    if (ioctl(preview_fd, PREV_G_CONFIG, &prev_chan_config) < 0) {
+        GST_DEBUG ("Error in getting configuration from previewer (%s)\n",
+                strerror(errno));
+        close(preview_fd);
+        return -1;
+    }
+
+    prev_chan_config.oper_mode = oper_mode;
+    prev_chan_config.len = sizeof(struct prev_continuous_config);
+    prev_chan_config.config = &prev_cont_config;
+    if (ioctl(preview_fd, PREV_S_CONFIG, &prev_chan_config) < 0) {
+        GST_DEBUG ("Error in setting previewer configuration (%s)\n",
+                    strerror(errno));
+        close(preview_fd);
+        return -1;
+    }
+
+    GST_DEBUG ("Previewer initialized\n");
+    return preview_fd;
+}
+
+static void
+gst_v4l2_delete_resize(gint fd)
+{
+    if (fd) {
+        if (close(fd) == -1) {
+            GST_DEBUG ("Failed to close resizer device (%s)\n",
+                strerror(errno));
+            return;
+        }
+    }
+}
+
+static void
+gst_v4l2_delete_preview(gint fd)
+{
+    if (fd) {
+        if (close(fd) == -1) {
+            GST_DEBUG ("Failed to close previewer device (%s)\n",
+                        strerror(errno));
+            return;
+        }
+    }
+}
+
+int dm365_resize_create(GstV4l2Object * v4l2object)
+{
+    resizer_fd = gst_v4l2_setresize_continuous();
+    if(resizer_fd <= 0) {
+        GST_DEBUG_OBJECT (v4l2object->element,
+            "Unable to configure resizer device\n");
+        return -1;
+    }
+
+    previewer_fd = gst_v4l2_setpreview_continuous();
+    if(previewer_fd <= 0) {
+        GST_DEBUG_OBJECT (v4l2object->element,
+            "Unable to configure previewer device\n");
+        return -1;
+    }
+    return 0;
+}
+
+int dm365_resize_destroy(GstV4l2Object * v4l2object)
+{
+    if(previewer_fd > 0) {
+        gst_v4l2_delete_preview(previewer_fd);
+        previewer_fd = -1;
+    }
+    if(resizer_fd > 0) {
+        gst_v4l2_delete_resize(resizer_fd);
+        resizer_fd = -1;
+    }
+    return 0;
+}
+#endif /* Platform_dm365 */
+#endif /* DAVINCI_LSP_WORKAROUND */
diff --git a/sys/v4l2/v4l2src_davinci.h b/sys/v4l2/v4l2src_davinci.h
new file mode 100644
index 0000000..eedc8bf
--- /dev/null
+++ b/sys/v4l2/v4l2src_davinci.h
@@ -0,0 +1,55 @@
+/*
+ * v42lsrc_davinci.h
+ *
+ * This file defines functions needed to get v4l2src on dm6446, dm355, dm6467
+ * , dm357 and dm365 LSP's.
+ *
+ * Most the code is copied from DMAI capture routines with following license:
+ *
+ * --COPYRIGHT--,BSD
+ * Copyright (c) 2009, Texas Instruments Incorporated
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * *  Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * *  Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * *  Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * --/COPYRIGHT--*/
+
+#ifndef __GST_DM365_RESIZER_H__
+#define __GST_DM365_RESIZER_H__
+
+#include <gstv4l2object.h>
+#include "v4l2src_calls.h"
+
+void  gst_v4l2src_get_resolution (GstV4l2Object *v4l2object, gint *width, 
+ gint *height, gint *fps_num, gint *fps_denom);
+void gst_v4l2src_convert_to_upper (char *str);
+int dm365_resize_create(GstV4l2Object * v4l2object);
+int dm365_resize_destroy(GstV4l2Object * v4l2object);
+gboolean gst_v4l2_force_720p_30 (GstV4l2Src * v4l2src);
+
+#endif /* __GST_DM365_RESIZER_H__ */
+
-- 
1.6.3.3

