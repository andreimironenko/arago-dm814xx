From 76415654f420d218540d0ae899e16483eecc3e92 Mon Sep 17 00:00:00 2001
From: Brijesh Singh <bksingh@ti.com>
Date: Sat, 5 Jun 2010 13:50:04 -0500
Subject: [PATCH] add "RTCodecThread" property

---
 src/gsttiauddec1.c |   21 ++++++++++++++++++---
 src/gsttiauddec1.h |    1 +
 src/gsttividdec2.c |   26 +++++++++++++++++++++++---
 src/gsttividdec2.h |    1 +
 4 files changed, 43 insertions(+), 6 deletions(-)

diff --git a/src/gsttiauddec1.c b/src/gsttiauddec1.c
index 55aac43..38eed1f 100644
--- a/src/gsttiauddec1.c
+++ b/src/gsttiauddec1.c
@@ -73,7 +73,8 @@ enum
   PROP_NUM_CHANNELS,    /* numChannels    (int)     */
   PROP_NUM_OUTPUT_BUFS, /* numOutputBufs  (int)     */
   PROP_DISPLAY_BUFFER,  /* displayBuffer  (boolean) */
-  PROP_GEN_TIMESTAMPS   /* genTimeStamps  (boolean) */
+  PROP_GEN_TIMESTAMPS,  /* genTimeStamps  (boolean) */
+  PROP_RTCODECTHREAD    /* rtCodecThread  (boolean) */
 };
 
 /* Define sink (input) pad capabilities.  Currently, AAC and MP3 are
@@ -284,6 +285,11 @@ static void gst_tiauddec1_class_init(GstTIAuddec1Class *klass)
             "Display circular buffer status while processing",
             FALSE, G_PARAM_WRITABLE));
 
+    g_object_class_install_property(gobject_class, PROP_RTCODECTHREAD,
+        g_param_spec_boolean("RTCodecThread", "Real time codec thread",
+            "Exectue codec calls in real-time thread",
+            TRUE, G_PARAM_WRITABLE));
+
     g_object_class_install_property(gobject_class, PROP_GEN_TIMESTAMPS,
         g_param_spec_boolean("genTimeStamps", "Generate Time Stamps",
             "Set timestamps on output buffers",
@@ -328,6 +334,13 @@ static void gst_tiauddec1_init_env(GstTIAuddec1 *auddec1)
                     auddec1->genTimeStamps ? "TRUE" : "FALSE");
     }
 
+    if (gst_ti_env_is_defined("GST_TI_TIAuddec1_RTCodecThread")) {
+        auddec1->rtCodecThread = 
+                gst_ti_env_get_boolean("GST_TI_TIAuddec1_RTCodecThread");
+        GST_LOG("Setting RTCodecThread =%s\n", 
+                    auddec1->rtCodecThread ? "TRUE" : "FALSE");
+    }
+
     GST_LOG("gst_tiauddec1_init_env - end");
 }
 
@@ -399,6 +412,8 @@ static void gst_tiauddec1_init(GstTIAuddec1 *auddec1, GstTIAuddec1Class *gclass)
     auddec1->totalBytes         = 0;
     auddec1->sampleRate         = 0;
 
+    auddec1->rtCodecThread      = TRUE;
+
     gst_tiauddec1_init_env(auddec1);
 }
 
@@ -882,8 +897,8 @@ static gboolean gst_tiauddec1_init_audio(GstTIAuddec1 * auddec1)
     }
 
     /* Create decoder thread */
-    if (pthread_create(&auddec1->decodeThread, &attr,
-            gst_tiauddec1_decode_thread, (void*)auddec1)) {
+    if (pthread_create(&auddec1->decodeThread, auddec1->rtCodecThread ? 
+        &attr : NULL, gst_tiauddec1_decode_thread, (void*)auddec1)) {
         GST_ELEMENT_ERROR(auddec1, RESOURCE, FAILED,
         ("failed to create decode thread\n"), (NULL));
         gst_tiauddec1_exit_audio(auddec1);
diff --git a/src/gsttiauddec1.h b/src/gsttiauddec1.h
index 4bda013..21baa48 100644
--- a/src/gsttiauddec1.h
+++ b/src/gsttiauddec1.h
@@ -68,6 +68,7 @@ struct _GstTIAuddec1
   gboolean       displayBuffer;
   gboolean       genTimeStamps;
   gint           sampleRate;
+  gboolean       rtCodecThread;
 
   /* Element state */
   Engine_Handle    hEngine;
diff --git a/src/gsttividdec2.c b/src/gsttividdec2.c
index 0e28b3e..d347044 100644
--- a/src/gsttividdec2.c
+++ b/src/gsttividdec2.c
@@ -72,7 +72,8 @@ enum
   PROP_NUM_OUTPUT_BUFS, /* numOutputBufs  (int)     */
   PROP_FRAMERATE,       /* frameRate      (int)     */
   PROP_DISPLAY_BUFFER,  /* displayBuffer  (boolean) */
-  PROP_GEN_TIMESTAMPS   /* genTimeStamps  (boolean) */
+  PROP_GEN_TIMESTAMPS,  /* genTimeStamps  (boolean) */
+  PROP_RTCODECTHREAD    /* rtCodecThread (boolean) */
 };
 
 /* Define sink (input) pad capabilities.  Currently, MPEG and H264 are 
@@ -311,6 +312,11 @@ static void gst_tividdec2_class_init(GstTIViddec2Class *klass)
             "Display circular buffer status while processing",
             FALSE, G_PARAM_WRITABLE));
 
+    g_object_class_install_property(gobject_class, PROP_RTCODECTHREAD,
+        g_param_spec_boolean("RTCodecThread", "Real time codec thread",
+            "Exectue codec calls in real-time thread",
+            TRUE, G_PARAM_WRITABLE));
+
     g_object_class_install_property(gobject_class, PROP_GEN_TIMESTAMPS,
         g_param_spec_boolean("genTimeStamps", "Generate Time Stamps",
             "Set timestamps on output buffers",
@@ -360,6 +366,13 @@ static void gst_tividdec2_init_env(GstTIViddec2 *viddec2)
         GST_LOG("Setting frameRate=%d\n", viddec2->framerateNum);
     }
 
+    if (gst_ti_env_is_defined("GST_TI_TIViddec2_RTCodecThread")) {
+        viddec2->rtCodecThread = 
+                gst_ti_env_get_boolean("GST_TI_TIViddec2_RTCodecThread");
+        GST_LOG("Setting RTCodecThread =%s\n", 
+                    viddec2->rtCodecThread ? "TRUE" : "FALSE");
+    }
+
     GST_LOG("gst_tividdec2_init_env - end\n");
 }
 
@@ -437,6 +450,8 @@ static void gst_tividdec2_init(GstTIViddec2 *viddec2, GstTIViddec2Class *gclass)
 
     viddec2->mpeg4_quicktime_header = NULL;
 
+    viddec2->rtCodecThread      = TRUE;
+
     gst_tividdec2_init_env(viddec2);
 }
 
@@ -521,6 +536,11 @@ static void gst_tividdec2_set_property(GObject *object, guint prop_id,
             GST_LOG("setting \"genTimeStamps\" to \"%s\"\n",
                 viddec2->genTimeStamps ? "TRUE" : "FALSE");
             break;
+        case PROP_RTCODECTHREAD:
+            viddec2->rtCodecThread = g_value_get_boolean(value);
+            GST_LOG("setting \"RTCodecThread\" to \"%s\"\n",
+                viddec2->rtCodecThread ? "TRUE" : "FALSE");
+            break;
         default:
             G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
             break;
@@ -1000,8 +1020,8 @@ static gboolean gst_tividdec2_init_video(GstTIViddec2 *viddec2)
     }
 
     /* Create decoder thread */
-    if (pthread_create(&viddec2->decodeThread, &attr,
-            gst_tividdec2_decode_thread, (void*)viddec2)) {
+    if (pthread_create(&viddec2->decodeThread, viddec2->rtCodecThread ? 
+            &attr : NULL, gst_tividdec2_decode_thread, (void*)viddec2)) {
         GST_ELEMENT_ERROR(viddec2, RESOURCE, FAILED,
         ("failed to create decode thread\n"), (NULL));
         gst_tividdec2_exit_video(viddec2);
diff --git a/src/gsttividdec2.h b/src/gsttividdec2.h
index 923339b..44a88a9 100644
--- a/src/gsttividdec2.h
+++ b/src/gsttividdec2.h
@@ -68,6 +68,7 @@ struct _GstTIViddec2
   const gchar*   codecName;
   gboolean       displayBuffer;
   gboolean       genTimeStamps;
+  gboolean       rtCodecThread;
 
   /* Element state */
   Engine_Handle    hEngine;
-- 
1.5.4.3

