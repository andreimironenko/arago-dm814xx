From 72d4a65e7af6d4da938ae9477b338ab069fe24dc Mon Sep 17 00:00:00 2001
From: Brijesh Singh <bksingh@ti.com>
Date: Fri, 2 Jul 2010 22:39:04 -0500
Subject: [PATCH 6/8] add "RTCodecThread" property

---
 src/gsttiauddec1.c |   26 +++++++++++++++++++++++---
 src/gsttiauddec1.h |    1 +
 src/gsttividdec2.c |   26 +++++++++++++++++++++++---
 src/gsttividdec2.h |    1 +
 4 files changed, 48 insertions(+), 6 deletions(-)

diff --git a/src/gsttiauddec1.c b/src/gsttiauddec1.c
index 04e90b4..bcafc09 100644
--- a/src/gsttiauddec1.c
+++ b/src/gsttiauddec1.c
@@ -73,7 +73,8 @@ enum
   PROP_NUM_CHANNELS,    /* numChannels    (int)     */
   PROP_NUM_OUTPUT_BUFS, /* numOutputBufs  (int)     */
   PROP_DISPLAY_BUFFER,  /* displayBuffer  (boolean) */
-  PROP_GEN_TIMESTAMPS   /* genTimeStamps  (boolean) */
+  PROP_GEN_TIMESTAMPS,  /* genTimeStamps  (boolean) */
+  PROP_RTCODECTHREAD    /* rtCodecThread  (boolean) */
 };
 
 /* Define sink (input) pad capabilities.  Currently, AAC and MP3 are
@@ -281,6 +282,11 @@ static void gst_tiauddec1_class_init(GstTIAuddec1Class *klass)
             "Display circular buffer status while processing",
             FALSE, G_PARAM_WRITABLE));
 
+    g_object_class_install_property(gobject_class, PROP_RTCODECTHREAD,
+        g_param_spec_boolean("RTCodecThread", "Real time codec thread",
+            "Exectue codec calls in real-time thread",
+            TRUE, G_PARAM_WRITABLE));
+
     g_object_class_install_property(gobject_class, PROP_GEN_TIMESTAMPS,
         g_param_spec_boolean("genTimeStamps", "Generate Time Stamps",
             "Set timestamps on output buffers",
@@ -325,6 +331,13 @@ static void gst_tiauddec1_init_env(GstTIAuddec1 *auddec1)
                     auddec1->genTimeStamps ? "TRUE" : "FALSE");
     }
 
+    if (gst_ti_env_is_defined("GST_TI_TIAuddec1_RTCodecThread")) {
+        auddec1->rtCodecThread = 
+                gst_ti_env_get_boolean("GST_TI_TIAuddec1_RTCodecThread");
+        GST_LOG("Setting RTCodecThread =%s\n", 
+                    auddec1->rtCodecThread ? "TRUE" : "FALSE");
+    }
+
     GST_LOG("gst_tiauddec1_init_env - end");
 }
 
@@ -395,6 +408,8 @@ static void gst_tiauddec1_init(GstTIAuddec1 *auddec1, GstTIAuddec1Class *gclass)
     auddec1->totalBytes         = 0;
     auddec1->sampleRate         = 0;
 
+    auddec1->rtCodecThread      = TRUE;
+
     gst_tiauddec1_init_env(auddec1);
 }
 
@@ -468,6 +483,11 @@ static void gst_tiauddec1_set_property(GObject *object, guint prop_id,
             GST_LOG("setting \"genTimeStamps\" to \"%s\"\n",
                 auddec1->genTimeStamps ? "TRUE" : "FALSE");
             break;
+        case PROP_RTCODECTHREAD:
+            auddec1->rtCodecThread = g_value_get_boolean(value);
+            GST_LOG("setting \"RTCodecThread\" to \"%s\"\n",
+                auddec1->rtCodecThread ? "TRUE" : "FALSE");
+            break;
         default:
             G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
             break;
@@ -877,8 +897,8 @@ static gboolean gst_tiauddec1_init_audio(GstTIAuddec1 * auddec1)
     }
 
     /* Create decoder thread */
-    if (pthread_create(&auddec1->decodeThread, &attr,
-            gst_tiauddec1_decode_thread, (void*)auddec1)) {
+    if (pthread_create(&auddec1->decodeThread, auddec1->rtCodecThread ? 
+        &attr : NULL, gst_tiauddec1_decode_thread, (void*)auddec1)) {
         GST_ELEMENT_ERROR(auddec1, RESOURCE, FAILED,
         ("failed to create decode thread\n"), (NULL));
         gst_tiauddec1_exit_audio(auddec1);
diff --git a/src/gsttiauddec1.h b/src/gsttiauddec1.h
index a35845c..eb9fbb0 100644
--- a/src/gsttiauddec1.h
+++ b/src/gsttiauddec1.h
@@ -69,6 +69,7 @@ struct _GstTIAuddec1
   gboolean       displayBuffer;
   gboolean       genTimeStamps;
   gint           sampleRate;
+  gboolean       rtCodecThread;
 
   /* Element state */
   Engine_Handle    hEngine;
diff --git a/src/gsttividdec2.c b/src/gsttividdec2.c
index 8ccca2a..a213d24 100644
--- a/src/gsttividdec2.c
+++ b/src/gsttividdec2.c
@@ -72,7 +72,8 @@ enum
   PROP_NUM_OUTPUT_BUFS, /* numOutputBufs  (int)     */
   PROP_FRAMERATE,       /* frameRate      (int)     */
   PROP_DISPLAY_BUFFER,  /* displayBuffer  (boolean) */
-  PROP_GEN_TIMESTAMPS   /* genTimeStamps  (boolean) */
+  PROP_GEN_TIMESTAMPS,  /* genTimeStamps  (boolean) */
+  PROP_RTCODECTHREAD    /* rtCodecThread (boolean) */
 };
 
 /* Define sink (input) pad capabilities.  Currently, MPEG and H264 are 
@@ -308,6 +309,11 @@ static void gst_tividdec2_class_init(GstTIViddec2Class *klass)
             "Display circular buffer status while processing",
             FALSE, G_PARAM_WRITABLE));
 
+    g_object_class_install_property(gobject_class, PROP_RTCODECTHREAD,
+        g_param_spec_boolean("RTCodecThread", "Real time codec thread",
+            "Exectue codec calls in real-time thread",
+            TRUE, G_PARAM_WRITABLE));
+
     g_object_class_install_property(gobject_class, PROP_GEN_TIMESTAMPS,
         g_param_spec_boolean("genTimeStamps", "Generate Time Stamps",
             "Set timestamps on output buffers",
@@ -357,6 +363,13 @@ static void gst_tividdec2_init_env(GstTIViddec2 *viddec2)
         GST_LOG("Setting frameRate=%d\n", viddec2->framerateNum);
     }
 
+    if (gst_ti_env_is_defined("GST_TI_TIViddec2_RTCodecThread")) {
+        viddec2->rtCodecThread = 
+                gst_ti_env_get_boolean("GST_TI_TIViddec2_RTCodecThread");
+        GST_LOG("Setting RTCodecThread =%s\n", 
+                    viddec2->rtCodecThread ? "TRUE" : "FALSE");
+    }
+
     GST_LOG("gst_tividdec2_init_env - end\n");
 }
 
@@ -433,6 +446,8 @@ static void gst_tividdec2_init(GstTIViddec2 *viddec2, GstTIViddec2Class *gclass)
 
     viddec2->mpeg4_quicktime_header = NULL;
 
+    viddec2->rtCodecThread      = TRUE;
+
     gst_tividdec2_init_env(viddec2);
 }
 
@@ -517,6 +532,11 @@ static void gst_tividdec2_set_property(GObject *object, guint prop_id,
             GST_LOG("setting \"genTimeStamps\" to \"%s\"\n",
                 viddec2->genTimeStamps ? "TRUE" : "FALSE");
             break;
+        case PROP_RTCODECTHREAD:
+            viddec2->rtCodecThread = g_value_get_boolean(value);
+            GST_LOG("setting \"RTCodecThread\" to \"%s\"\n",
+                viddec2->rtCodecThread ? "TRUE" : "FALSE");
+            break;
         default:
             G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
             break;
@@ -1007,8 +1027,8 @@ static gboolean gst_tividdec2_init_video(GstTIViddec2 *viddec2)
     }
 
     /* Create decoder thread */
-    if (pthread_create(&viddec2->decodeThread, &attr,
-            gst_tividdec2_decode_thread, (void*)viddec2)) {
+    if (pthread_create(&viddec2->decodeThread, viddec2->rtCodecThread ? 
+            &attr : NULL, gst_tividdec2_decode_thread, (void*)viddec2)) {
         GST_ELEMENT_ERROR(viddec2, RESOURCE, FAILED,
         ("failed to create decode thread\n"), (NULL));
         gst_tividdec2_exit_video(viddec2);
diff --git a/src/gsttividdec2.h b/src/gsttividdec2.h
index 5233fd4..b443cc1 100644
--- a/src/gsttividdec2.h
+++ b/src/gsttividdec2.h
@@ -69,6 +69,7 @@ struct _GstTIViddec2
   const gchar*   codecName;
   gboolean       displayBuffer;
   gboolean       genTimeStamps;
+  gboolean       rtCodecThread;
 
   /* Element state */
   Engine_Handle    hEngine;
-- 
1.7.0.4

